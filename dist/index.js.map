{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/// <reference lib=\"dom\" />\n/// <reference lib=\"dom.iterable\" />\n\nimport { decode, encode } from '@msgpack/msgpack';\nimport pako from 'pako';\n\ntype Meta = string[][];\ntype MetaMap = { [key: string]: number };\n\nfunction fromPackValue(v: unknown): unknown {\n  if (!Array.isArray(v) || v.length !== 2) {\n    throw new Error('Bad pack value format');\n  }\n  const [meta, value] = v;\n  if (!Array.isArray(meta) || !meta.every(a => Array.isArray(a))) {\n    throw new Error('Bad pack value meta format');\n  }\n\n  return convertValue(value);\n\n  function convertValue(v: unknown): unknown {\n    switch (typeof v) {\n      case 'object':\n        if (Array.isArray(v)) {\n          if (v.length < 1) {\n            throw new Error('Bad pack array value');\n          }\n          const tag = v[0];\n          if (Array.isArray(tag)) {\n            const r: Record<string, unknown> = {};\n            for (let i = 0; i < tag.length; i++) {\n              let key = tag[i];\n              if (typeof key === 'number') {\n                key = meta[0][-key - 1];\n              }\n              r[key] = convertValue(v[i + 1]);\n            }\n            return r;\n          }\n          if (tag === 0) {\n            return v.slice(1).map(convertValue);\n          }\n          if (tag < 0) {\n            return meta[0][-tag - 1];\n          }\n          const r: Record<string, unknown> = {};\n          const fields = meta[tag];\n          for (let i = 0; i < fields.length; i++) {\n            r[fields[i]] = convertValue(v[i + 1]);\n          }\n          return r;\n        }\n        return v;\n      default:\n        return v;\n    }\n  }\n}\n\nasync function unpack(data: string): Promise<unknown> {\n  // 创建一个 data URL 并获取原始数据\n  const res = await fetch(`data:application/octet-stream;base64,${data}`);\n  const buf = await res.arrayBuffer();\n\n  // 使用 pako 解压 ArrayBuffer 数据\n  let decompressed: Uint8Array;\n  try {\n    decompressed = pako.inflate(new Uint8Array(buf));\n  } catch (error) {\n    console.error('Decompression failed:', error);\n    throw error;\n  }\n\n  // 修改这部分代码，避免使用 ReadableStream\n  try {\n    const blob = new Blob([decompressed]);\n    const buffer = await blob.arrayBuffer();\n    const r = decode(buffer);\n    return fromPackValue(r);\n  } catch (error) {\n    console.error('Decoding failed:', error);\n    throw error;\n  }\n}\n\nfunction toPackValueWithMeta(\n  meta: Meta,\n  metamap: MetaMap,\n  key: string | undefined,\n  value: unknown,\n): unknown {\n  switch (typeof value) {\n    case 'string':\n      return value;\n    case 'object': {\n      if (value === null) {\n        return null;\n      }\n      if (Array.isArray(value)) {\n        return [\n          0,\n          ...value.map(v =>\n            toPackValueWithMeta(\n              meta,\n              metamap,\n              undefined,\n              v,\n            ),\n          ),\n        ];\n      }\n      const keys = Object.keys(value);\n      keys.sort();\n      const mapk = keys.join(',');\n      let metaindex = metamap[mapk];\n      if (!metaindex) {\n        metaindex = meta.length;\n        metamap[mapk] = metaindex;\n        meta.push(keys);\n      }\n      return [\n        metaindex,\n        ...keys.map(key =>\n          toPackValueWithMeta(\n            meta,\n            metamap,\n            key,\n            value[key],\n          ),\n        ),\n      ];\n    }\n    default:\n      return value;\n  }\n}\n\nfunction toPackValue(\n  v: unknown,\n): [Meta, unknown] {\n  const meta: Meta = [[]];\n  const value = toPackValueWithMeta(\n    meta,\n    {},\n    undefined,\n    v,\n  );\n  return [meta, value];\n}\n\n/**\n * 将一个对象进行压缩序列化\n * @param v - 要序列化的对象\n * @returns 压缩后的数据，以base64字符串的形式表示\n */\nasync function pack(\n  v: unknown,\n): Promise<string> {\n  const packed = toPackValue(v);\n  const mp = encode(packed);\n\n  const compressed = pako.gzip(mp);\n  const blob = new Blob([compressed]);\n\n  if (typeof window !== 'undefined') {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const result = reader.result;\n        if (typeof result === 'string') {\n          resolve(result.split(',')[1]);\n        } else {\n          reject(new Error('Failed to convert blob to base64'));\n        }\n      };\n      reader.onerror = () => reject(reader.error);\n      reader.readAsDataURL(blob);\n    });\n  }\n  const buffer = await blob.arrayBuffer();\n  return Buffer.from(buffer).toString('base64');\n}\n\nexport { pack, unpack };\nexport default { pack, unpack }; "],"mappings":"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","names":["v","r","pako","key"]}