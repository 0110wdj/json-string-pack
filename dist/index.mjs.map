{"version":3,"sources":["../src/index.ts"],"names":["v","r","key"],"mappings":"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","file":"index.mjs","sourcesContent":["/// <reference lib=\"dom\" />\n/// <reference lib=\"dom.iterable\" />\n\nimport { decode, encode } from '@msgpack/msgpack';\nimport pako from 'pako';\n\ntype Meta = string[][];\ntype MetaMap = { [key: string]: number };\n\nfunction fromPackValue(v: unknown): unknown {\n  if (!Array.isArray(v) || v.length !== 2) {\n    throw new Error('Bad pack value format');\n  }\n  const [meta, value] = v;\n  if (!Array.isArray(meta) || !meta.every(a => Array.isArray(a))) {\n    throw new Error('Bad pack value meta format');\n  }\n\n  return convertValue(value);\n\n  function convertValue(v: unknown): unknown {\n    switch (typeof v) {\n      case 'object':\n        if (Array.isArray(v)) {\n          if (v.length < 1) {\n            throw new Error('Bad pack array value');\n          }\n          const tag = v[0];\n          if (Array.isArray(tag)) {\n            const r: Record<string, unknown> = {};\n            for (let i = 0; i < tag.length; i++) {\n              let key = tag[i];\n              if (typeof key === 'number') {\n                key = meta[0][-key - 1];\n              }\n              r[key] = convertValue(v[i + 1]);\n            }\n            return r;\n          }\n          if (tag === 0) {\n            return v.slice(1).map(convertValue);\n          }\n          if (tag < 0) {\n            return meta[0][-tag - 1];\n          }\n          const r: Record<string, unknown> = {};\n          const fields = meta[tag];\n          for (let i = 0; i < fields.length; i++) {\n            r[fields[i]] = convertValue(v[i + 1]);\n          }\n          return r;\n        }\n        return v;\n      default:\n        return v;\n    }\n  }\n}\n\nasync function unpack(data: string): Promise<unknown> {\n  // 创建一个 data URL 并获取原始数据\n  const res = await fetch(`data:application/octet-stream;base64,${data}`);\n  const buf = await res.arrayBuffer();\n\n  // 使用 pako 解压 ArrayBuffer 数据\n  let decompressed: Uint8Array;\n  try {\n    decompressed = pako.inflate(new Uint8Array(buf));\n  } catch (error) {\n    console.error('Decompression failed:', error);\n    throw error;\n  }\n\n  // 修改这部分代码，避免使用 ReadableStream\n  try {\n    const blob = new Blob([decompressed]);\n    const buffer = await blob.arrayBuffer();\n    const r = decode(buffer);\n    return fromPackValue(r);\n  } catch (error) {\n    console.error('Decoding failed:', error);\n    throw error;\n  }\n}\n\nfunction toPackValueWithMeta(\n  meta: Meta,\n  metamap: MetaMap,\n  key: string | undefined,\n  value: unknown,\n): unknown {\n  switch (typeof value) {\n    case 'string':\n      return value;\n    case 'object': {\n      if (value === null) {\n        return null;\n      }\n      if (Array.isArray(value)) {\n        return [\n          0,\n          ...value.map(v => toPackValueWithMeta(meta, metamap, undefined, v)),\n        ];\n      }\n      const keys = Object.keys(value);\n      keys.sort();\n      const mapk = keys.join(',');\n      let metaindex = metamap[mapk];\n      if (!metaindex) {\n        metaindex = meta.length;\n        metamap[mapk] = metaindex;\n        meta.push(keys);\n      }\n      return [\n        metaindex,\n        ...keys.map(key => toPackValueWithMeta(meta, metamap, key, value[key])),\n      ];\n    }\n    default:\n      return value;\n  }\n}\n\nfunction toPackValue(v: unknown): [Meta, unknown] {\n  const meta: Meta = [[]];\n  const value = toPackValueWithMeta(meta, {}, undefined, v);\n  return [meta, value];\n}\n\n/**\n * 将一个对象进行压缩序列化\n * @param v - 要序列化的对象\n * @returns 压缩后的数据，以base64字符串的形式表示\n */\nasync function pack(v: unknown): Promise<string> {\n  const packed = toPackValue(v);\n  const mp = encode(packed);\n\n  const compressed = pako.gzip(mp);\n  const blob = new Blob([compressed]);\n\n  if (typeof window !== 'undefined') {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const result = reader.result;\n        if (typeof result === 'string') {\n          resolve(result.split(',')[1]);\n        } else {\n          reject(new Error('Failed to convert blob to base64'));\n        }\n      };\n      reader.onerror = () => reject(reader.error);\n      reader.readAsDataURL(blob);\n    });\n  }\n  const buffer = await blob.arrayBuffer();\n  return Buffer.from(buffer).toString('base64');\n}\n\nexport { pack, unpack };\nexport default { pack, unpack };\n"]}